#!perl
# The function of this program is to screen all the unfiltered sequences in the
# raw_seqs table, and place the results in the filter_seqs table.

# Copyright (c) 2009 Robert E. Bruccoleri
# All rights reserved.

# Portions of this code are derived from SEEBUGS,
# which is copyrighted by Bristol-Myers Squibb,
# and those portions are subject to the copyright notice below,
# but the entirety of the program is copyrighted by Robert E. Bruccoleri
# and is available under the GNU Public License version 2

# Copyright (c) 1998 Bristol-Myers Squibb Company

# This software and related documentation is being provided by
# Bristol-Myers Squibb Company and Robert E. Bruccoleri under the
# following license.  By obtaining, using and/or copying this
# software, you agree that you have read, understood, and will comply
# with the following terms and conditions:

# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice and this permission notice
# and warranty disclaimer appear in all copies.

# BRISTOL-MYERS SQUIBB COMPANY AND ROBERT E. BRUCCOLERI DISCLAIM, AND
# THE USER WAIVES, ALL REPRESENTATIONS AND WARRANTIES, EXPRESS OR
# IMPLIED, WITH REGARD TO THIS SOFTWARE AND ITS RELATED DOCUMENTATION,
# INCLUDING WITHOUT LIMITATION ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS FOR A PARTICULAR USE OR PURPOSE.  BRISTOL-MYERS SQUIBB
# COMPANY AND ROBERT E. BRUCCOLERI MAKE NO REPRESENTATION OR WARRANTY,
# EXPRESS OR IMPLIED, AS TO WHETHER THE USE OF THIS SOFTWARE AND ITS
# RELATED DOCUMENTATION INFRINGES ANY PATENT, COPYRIGHT, OR OTHER
# INTELLECTUAL PROPERTY RIGHT OF ANY OTHER PARTY. IN NO EVENT SHALL
# BRISTOL-MYERS SQUIBB COMPANY OR ROBERT E. BRUCCOLERI BE LIABLE FOR ANY
# SPECIAL, DIRECT, INDIRECT, INCIDENTAL, PUNITIVE, OR CONSEQUENTIAL
# DAMAGES, OR ANY OTHER DAMAGES OF ANY NATURE WHATSOEVER, THAT MAY BE
# INCURRED BY THE USER OR ANY OTHER PARTY ARISING OUT OF OR IN
# CONNECTION WITH ANY USE OR PERFORMANCE OF THIS SOFTWARE OR ANY USE OF
# ANY DATA OR RESULTS GENERATED BY THE SOFTWARE, INCLUDING WITHOUT
# LIMITATION LOSS OF DATA AND LOST PROFITS OR REVENUES, WHETHER OR NOT
# BRISTOL-MYERS SQUIBB COMPANY OR ROBERT E. BRUCCOLERI HAVE BEEN ADVISED
# OF THE POSSIBILITY OF DAMAGES, AND USER HEREBY WAIVES, RELEASES, AND
# FOREVER DISCLAIMS ALL DAMAGES, CLAIMS, AND CAUSES OF ACTION IT MAY
# HAVE AGAINST BRISTOL-MYERS SQUIBB COMPANY OR ROBERT E. BRUCCOLERI WITH
# RESPECT TO ANY LOSSES, DAMAGES, COSTS, EXPENSES, AND LIABILITIES OF
# ANY NATURE THAT MAY BE INCURRED BY IT ARISING OUT OF OR IN CONNECTION
# WITH USER'S USE OF THE SOFTWARE AND ITS RELATED DOCUMENTATION.  USER
# SHALL BE SOLELY RESPONSIBLE FOR ALL LOSSES, DAMAGES, COSTS, EXPENSES,
# AND LIABILITIES OF ANY NATURE INCURRED BY USER RESULTING FROM OR IN
# CONNECTION WITH USER'S USE OF THE SOFTWARE AND ITS RELATED
# DOCUMENTATION.  THE USER UNDERSTANDS AND ACCEPTS THE ABOVE LIMITATIONS
# ON DAMAGES AND REMEDIES AS A CONDITION OF OBTAINING USE OF THE
# SOFTWARE AND RELATED DOCUMENTATION WITHOUT CHARGE.

use warnings;
use strict;

use SHA;

use Getopt::Long;
use Text::Wrap;

use Bio::Frescobi::CgPg;
use Bio::Frescobi::Sequtil;
use Bio::Frescobi::Genutil;
use Bio::Frescobi::Dbseq;
use Bio::Frescobi::Frescobi;
use Bio::Frescobi::Config;
use Bio::Frescobi::BigQuery;

my $usage = <<EOF;
update_filtered_seqs.pl [-maxproc=<int>	   ] filter-program
		        [-tmp=<dir>	   ]
			[-filtersize=<int> ]
			 -dbname=<dbname>  
                        [-driver=<string>  ]
			[-library=<string> ]
			[-[no]redo         ]
                        [-seqtype=string   ]
EOF

my $filtersize = 200;
my $maxproc = 1;
my $workdir = "";
my $library = "";
my $redo = 0;
my $seq_type = "nucleic";
my $driver = "Pg";
my $dbname = "";
my $file_count;
my %names_to_filter = ();
my @tmpfiles;
my %filtered_names = ();

&GetOptions("maxproc=i" => \$maxproc,
	    "tmp=s" => \$workdir,
	    "filtersize=i" => \$filtersize,
	    "dbname=s" => \$dbname,
	    "driver=s" => \$driver,
	    "library=s" => \$library,
	    "seqtype=s" => \$seq_type,
	    "redo!", \$redo);

if ($workdir eq "") {
    $workdir = $tmpdir . "/filter";
}

set_line_buffering;

if ($dbname eq "") {
    die "The database name, (-dbname), must be specified.\n";
}

if ($seq_type !~ m/^(nucleic|protein)$/) {
    print STDERR "Sequence type must be either nucleic or protein\n";
    exit 1;
}

if (! -d $workdir) {
    system_with_check("mkdir -p $workdir");
    system_with_check("chmod 755 $workdir");
}
if ($#ARGV < 0) {
    print STDERR "A filtering program must be specified for this script.\n";
    print STDERR "$usage";
    die;
}

my $filter_prog = $ARGV[0];

if (not -x $filter_prog) {
    die "$filter_prog is not executable.\n";
}

my $libselect = "";
if ($library) {
    $libselect = "r.library = " . quotify($library);
}

my $pg = Bio::Frescobi::CgPg::new(dbname => $dbname,
				  driver => $driver,
				  cgi => "no");
$pg->default_echo("on");

&fetch_sequences;
&run_filter_in_parallel;
$pg->reset;

&delete_existing_filtered_sequences;
&load_new_filtered_sequences;
&update_duplicates($pg, "filtered_seqs");
# &update_action_bool($pg, "filtered_seqs", "compared");
&check_completion;
$pg->close_connection;

sub fetch_sequences {
    # Fetch sequences to be filtered and partition them into $maxproc files.

    my ($data, $i, $count);
    my ($irec, $name, $seq, $qual, $ifile);
    my ($prev_seqid, $prev_name, $prev_segnum, $segnum, $seqid, $seq_piece, $qual_piece);
    my ($where_clause);

    $count = 0;
    $ifile = 0;
    $prev_seqid = "";
    $prev_name = "";
    $seq = "";
    $qual = "";
    $where_clause = "r.seqid = p.seqid";
    $where_clause .= " and (not r.filtered)" unless $redo;
    $where_clause .= " and $libselect" if $libselect;

    my $query = Bio::Frescobi::BigQuery->new($pg,
					     "   SELECT r.name, r.seqid, p.segnum, p.seq_piece, p.qual_piece " .
					     "     FROM raw_seqs r, seq_pieces p " .
					     "    WHERE $where_clause " .
					     "    ORDER by r.name, r.seqid, p.segnum");
    while (my $rowp = $query->next) {
	($name, $seqid, $segnum, $seq_piece, $qual_piece) = @{$rowp};
	if ($prev_name ne $name) {
	    if ($prev_name ne "") {
		&write_1_seq($count, $ifile, $prev_name, $prev_seqid, $seq, $qual);
	    }
	    $prev_seqid = $seqid;
	    $prev_name = $name;
	    $prev_segnum = $segnum;
	    $seq = "";
	    $qual = "";
	}
	elsif ($segnum != $prev_segnum + 1) {
	    print STDERR "Sequence pieces for $seqid are out of order ($prev_segnum $segnum)\n";
	}
	$prev_segnum = $segnum;
	$seq .= $seq_piece;
	$qual .= $qual_piece;
    }
    if ($prev_seqid ne "") {
	&write_1_seq($count, $ifile, $prev_name, $prev_seqid, $seq, $qual);
    }
    close SEQ;
    close QUAL;
    $file_count = $ifile;
}

sub write_1_seq {
    my ($count, $ifile, $name, $seqid, $seq, $qual) = @_;
    my ($ofile, $qfile);

    $names_to_filter{$name} = 1;
    if (($count % $filtersize) == 0) {
	$ifile += 1;
	$ofile = "$workdir/filter_$ifile.seq";
	open (SEQ, ">$ofile") || die "Unable to open $ofile: $!\n";
	push (@tmpfiles, $ofile);
	$qfile = "$workdir/filter_$ifile.seq.qual";
	open (QUAL, ">$qfile") || die "Unable to open $qfile: $!\n";
	push (@tmpfiles, $qfile);
    }
    printf SEQ ">%s %s\n%s", $name, $seqid, format_seq($seq);
    if (length($qual) == 0) {
	$qual = "15 " x length($seq);
	if ($qual ne "") {
	    $qual = substr($qual, 0, length($qual) - 1);
	}
    }
    printf QUAL ">%s %s quality scores\n%s", $name, $seqid, format_qual($qual);
    $count += 1;
    $_[0] = $count;
    $_[1] = $ifile;
}

sub run_filter_in_parallel {
    my ($iproc, $pid, @pids, $file, $name1, $name2, $score);
    my ($homolog_found, $fmt, $arg, $command, $dir, $complement);
    local ($_);

    for ($iproc = 0; $iproc < $maxproc; $iproc++) {
 	if ($pid = fork) {
 	    print STDERR "Process $pid forked.\n";
	    sleep 2;
 	    push @pids, $pid;
 	}
 	elsif (defined $pid) {
	    my ($ifile, $date);
	    for ($ifile = 1; $ifile <= $file_count; $ifile++) {
		if (($ifile % $maxproc) == $iproc) {
		    my $cmd = "$filter_prog " .
			"$workdir/filter_$ifile.seq $workdir/filter_$ifile.seq.qual ".
			"$workdir/filter_$ifile.filtered $workdir/filter_$ifile.filtered.qual";
		    $date = &date;
		    print STDERR "At $date: $cmd\n";
		    system_with_check($cmd);
		}
	    }
	    exit;
	}
	else {
	    die "Can't fork: $!\n";
	}
    }
    foreach $pid (@pids) {
	waitpid($pid, 0);
    }
}


sub delete_existing_filtered_sequences {
    my ($data, $i, $name, $keyclause);
    my (@seqs_to_delete);

    $data = $pg->query("select distinct name from filtered_seqs");
    for my $rowp (@{$data}) {
	$name = $rowp->[0];
	if (exists $names_to_filter{$name}) {
	    push (@seqs_to_delete, $name);
	}
    }
    $keyclause = "";
    foreach $name (@seqs_to_delete) {
	if ($keyclause ne "") {
	    $keyclause .= " or";
	}
	$keyclause .= " name = " . quotify($name);
	if (length($keyclause) > 7000) {
	    $pg->command("delete from filtered_seqs where $keyclause");
	    $keyclause = "";
	}
    }
    if ($keyclause ne "") {
	$pg->command("delete from filtered_seqs where $keyclause");
    }
}

sub load_new_filtered_sequences {
    my ($result, $ifile, $file, $name, $count);
    my (%seq, %qual, @qual, $i, $seqid, $cmd, $seq, $qual, $compare_flag);
    my (%old_seq, %old_qual);
    my (@annotations_to_load, @sequences_to_load, @names_to_load);
    my (@quals_to_load);
    my (@duplicate_lines);
    my $curtime;
    if ($driver eq 'Pg') {
	$curtime = $pg->get_single_value("select 'now'::timestamp with time zone");
    }
    else {
	$curtime = $pg->get_single_value("select datetime('now', 'localtime')");
    }
	

    my $seqobj = Bio::Frescobi::Dbseq::new($pg);
    $seqobj->set_seqid_head("NF" . $pg->nextval('seqid_serial') . "_");
    $seqobj->setup_table("filtered_seqs");
    $seqobj->default_seq_type($seq_type);
    $seqobj->begin;

    $count = 0;
    for ($ifile = 1; $ifile <= $file_count; $ifile++) {
	&read_in_file("$workdir/filter_$ifile.seq",
		      \%old_seq,
		      0);
	&read_in_file("$workdir/filter_$ifile.seq.qual",
		      \%old_qual,
		      1);
	&read_in_file("$workdir/filter_$ifile.filtered",
		      \%seq,
		      0);
	&read_in_file("$workdir/filter_$ifile.filtered.qual",
		      \%qual,
		      1);

	foreach $name (keys %seq) {
	    if (not exists $qual{$name}) {
		print STDERR "Filtered sequence $name is missing a quality entry\n";
	    }
	}
	foreach $name (keys %qual) {
	    if (not exists $seq{$name}) {
		print STDERR "Quality entry $name is missing a sequence entry\n";
	    }
	}
	foreach $name (sort keys %seq) {
	    $filtered_names{$name} = 1;
	    @qual = qual_to_array($qual{$name});
	    if (scalar(@qual) > 0) {
		if (length($seq{$name}) != scalar(@qual)) {
		    printf STDERR "The number quality scores for $name = %d does not match the sequence length %d\n",
		    scalar(@qual), length($seq{$name});
		}
		else {
		    $seq = $seq{$name};
		    for ($i = 0; $i < scalar(@qual); $i++) {
			if (substr($seq, $i, 1) =~ /[xXnN]/) {
			    $qual[$i] = 0;
			}
		    }
		    $qual{$name} = array_to_qual(@qual);
		}
	    }
	    $seqobj->add_data({ "name" => $name,
				"seq" => $seq{$name},
				"qual" => $qual{$name},
				"create_time" => $curtime,
				"compared" => length($seq{$name}) == 0 ? 't' : 'f'
				});
	}
    }
    $seqobj->finish;
    $seqobj = undef;
    &update_filtered;
}

sub read_in_file {
    my ($file, $data, $is_qual) = @_;
    local (*IN);
    my ($line, $name, $annotation, $seq);

    %{$data} = ();
    print STDERR "Now processing $file:\n";
    open (IN, "<$file") || die "Unable to open $file: $!\n";
    $line = <IN>;
    while (defined $line) {
	($name, $annotation, $seq) = read_1_fasta_sequence(\*IN, $line, $is_qual);
	last if not defined $name;
	$data->{$name} = $seq;
    }
    close IN;
}

sub update_filtered {
    my ($result, $sql);

    $sql = "update raw_seqs set filtered = 't' where not filtered";
    if ($libselect) {
	$sql .= " and $libselect";
	$sql =~ s/r\.lib/lib/;
    }
    $result = $pg->command($sql);
}

sub check_completion {
    my ($name);

    foreach $name (keys %names_to_filter) {
	if (not exists($filtered_names{$name})) {
	    print STDERR "Sequence $name was not filtered as expected.\n";
	}
    }
}

sub update_action_bool {
    # Set all the action field values (like compared or filtered) for
    # duplicated names to 0 if they are all 0 or 1 if any are on.
    
   my ($pg, $table, $field_name) = @_;
   my $duplicate_table = "duplicate_" . $table;
   my ($i, $name, $seqid, $field_value, $prev_seqid);
   my ($cnt_on, $cnt_off, $cmd);
   
   my $datap = $pg->query("select d.name, d.seqid, t.$field_name " .
			  "       from $duplicate_table d, $table t " .
			  "       where d.name = t.$field_name and d.seqid = t.seqid " .
			  "       order by seqid, $field_name");
   $prev_seqid = "";
   foreach my $rowp (@{$datap}) {
       ($name, $seqid, $field_value) = @{$rowp};
       if ($prev_seqid ne $seqid) {
	   if ($prev_seqid ne "") {
	       if ($cnt_on > 0 && $cnt_off > 0) {
		   $cmd = "update $table set $field_name = 't' where seqid = '$prev_seqid'";
		   $pg->command($cmd);
	       }
	   }
	   $cnt_on = 0;
	   $cnt_off = 0;
	   $prev_seqid = $seqid;
       }
       $cnt_on += 1 if $field_value eq 't';
       $cnt_off += 1 if $field_value eq 'f';
   }
   if ($prev_seqid ne "") {
       if ($cnt_on > 0 && $cnt_off > 0) {
	   $cmd = "update $table set $field_name = 't' where seqid = '$prev_seqid'";
	   $pg->command($cmd);
       }
   }
}

